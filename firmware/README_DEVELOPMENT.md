# ESP32 Locomotive Controller - Development Guide

## Project Overview

This MicroPython project for ESP32 creates a locomotive controller for Rocrail model railway systems. The device operates in two modes based on button presses at startup:

1. **Configuration Mode** - Web-based setup for WiFi and Rocrail parameters
2. **Controller Mode** - Active locomotive control via WiFi connection to Rocrail

## System Architecture

### Boot Process (`boot.py`)
The entry point determines operating mode:
- **Red button pressed**: Starts configuration web server
- **Green button pressed**: Test mode (incomplete)
- **No button**: Normal locomotive control mode

‚ö†Ô∏è **Bug Note**: Boot.py checks `red_button.value()` twice instead of checking green button.

### Two Main Operating Modes

#### 1. Configuration Mode (`wifi_config_server.py`)
- Creates WiFi Access Point (AP_SSID: "ESP_Config")
- Serves web interface from `frontend/` folder
- Manages WiFi networks (up to 5 saved networks)
- Configures Rocrail server settings
- NeoPixel LED status indicators
- Potentiometer brightness control

#### 2. Controller Mode (`rocrail_controller.py`)
- Connects to saved WiFi network
- Establishes socket connection to Rocrail server
- Controls locomotive via XML commands
- Handles potentiometer and button inputs
- Real-time speed/direction control

## File Structure & Importance

### üî¥ CRITICAL Files (Core Functionality)
- `boot.py` - System entry point, mode selection
- `rocrail_controller.py` - Main locomotive control logic
- `wifi_config_server.py` - Configuration web server (NOT config_web_server.py)
- `btn_config.py` - Hardware pin assignments

### üü° IMPORTANT Library Files (`lib/`)
- `loco_controller.py` - High-level locomotive control class
- `button_controller.py` - Button input with debouncing
- `poti_controller.py` - Potentiometer input filtering
- `wifi_manager.py` - WiFi connection management
- `interval_timer.py` - Non-blocking timing utilities

### üü¢ CONFIGURATION Files
- `rocrail_config.py` - Default settings (WiFi, Rocrail, pins, timing)
- `wifi_networks.txt` - Saved WiFi credentials (JSON format)
- `rocrail_config.txt` - Rocrail server IP/port

### üîµ FRONTEND Files (Web Interface)
- `frontend/index.html` - Configuration web page
- `frontend/app.js` - JavaScript functionality
- `frontend/style.css` - Web interface styling
- `frontend/app_nonminified.js` - Debug version

## Hardware Configuration

### Button Assignments (`btn_config.py`)
```python
BTN_NOTHALT = 17          # Red emergency/config button
BTN_RICHTUNGSWECHEL = 19  # Green direction/test button
BTN_GELB = 22             # Yellow button
BTN_BLAU = 23             # Blue button
BTN_MITTE_UP = 21         # Black up button
BTN_MITTE_DOWN = 18       # Black down button
ADC_GESCHWINDIGKEIT = 34  # Speed potentiometer
```

### Controller Mode Hardware
```python
LIGHT_BUTTON_PIN = 34     # Light on/off
WHISTLE_BUTTON_PIN = 32   # Horn/whistle
DIRECTION_BUTTON_PIN = 33 # Direction toggle
SOUND_BUTTON_PIN = 35     # Sound on/off
EMERGENCY_BUTTON_PIN = 39 # Emergency stop
POTI_PIN = 36            # Speed potentiometer
LED_PIN = 5              # Status LED
```

## Communication Protocol

### Rocrail XML Commands
The system communicates with Rocrail using XML over TCP socket:

```xml
<!-- Speed Control -->
<xmlh><xml size="35"/></xmlh><lc id="BR103" V="50" dir="true"/>

<!-- Light Control -->
<xmlh><xml size="28"/></xmlh><fn id="BR103" fn0="true"/>

<!-- Emergency Stop -->
<xmlh><xml size="32"/></xmlh><lc id="BR103" V="0" dir="true"/>
```

## Development Workflow

### üîß Key Files for Development Tasks

#### Modifying Control Logic
1. `rocrail_controller.py` - Main control loop
2. `lib/loco_controller.py` - Locomotive command abstraction
3. `rocrail_config.py` - Default settings

#### Adding Hardware Components
1. `btn_config.py` - Pin assignments
2. `lib/button_controller.py` - Button handling
3. `lib/poti_controller.py` - Analog input

#### Web Interface Changes
1. `frontend/index.html` - UI structure
2. `frontend/app.js` - Client logic
3. `wifi_config_server.py` - API endpoints

#### Network/WiFi Features
1. `lib/wifi_manager.py` - Connection management
2. `wifi_config_server.py` - AP and web server

### üö´ Files to AVOID Modifying (Unless Necessary)
- `frontend/app_nonminified.js` - Debug version only
- `wifi_networks.txt` - Generated by web interface
- `rocrail_config.txt` - Generated by web interface

## Memory Optimization

The project uses several memory optimization techniques:
- Stream file serving in chunks (4KB)
- Garbage collection in main loops
- Response caching with timeouts
- Buffer size limits for socket communication

## API Endpoints (Configuration Mode)

```
GET  /api/status          - Device info and status
GET  /api/networks        - Scan WiFi networks
GET  /api/wifi-networks   - Get saved networks
POST /api/wifi-networks   - Add/update network
DELETE /api/wifi-networks/{ssid} - Remove network
GET  /api/rocrail         - Get Rocrail config
POST /api/rocrail         - Save Rocrail config
POST /api/test           - Test WiFi connection
POST /api/restart        - Restart device
```

## Common Development Tasks

### Adding New Button Functions
1. Add pin definition to `btn_config.py`
2. Create ButtonController in `rocrail_controller.py`
3. Add check in main loop with timer interval
4. Implement XML command in locomotive controller

### Modifying Speed Control
1. Edit `lib/poti_controller.py` for input processing
2. Modify speed mapping in `rocrail_controller.py`
3. Update timing intervals in `rocrail_config.py`

### Adding New Locomotive Commands
1. Add method to `lib/loco_controller.py`
2. Define XML command format
3. Add button/trigger in main controller

## Debugging & Monitoring

### Status Indicators
- **NeoPixel LEDs** (Configuration mode):
  - LED 0: Configuration started (green)
  - LED 1: AP status (green=active)
  - LED 2: Connection activity (blue/yellow)
  - LED 3: Error status (red)
  - LED 4: WiFi connected (green)
  - LED 5: Temperature (green/yellow/red)

- **Onboard LED** (Controller mode):
  - Flash on successful command transmission

### Error Handling
- Error logging to `error_log.txt` in configuration mode
- Console output for debugging
- Automatic reconnection attempts
- Graceful degradation on component failures

## Next Steps for Development

1. **Fix Boot Bug**: Correct green button detection in `boot.py`
2. **Complete Test Mode**: Implement test functionality
3. **Add Locomotive Selection**: Multiple locomotive support
4. **Enhanced Error Recovery**: Better connection handling
5. **Configuration Validation**: Input validation improvements

This guide provides the foundation for understanding and developing the locomotive controller system. Focus on the CRITICAL and IMPORTANT files for most development tasks.
